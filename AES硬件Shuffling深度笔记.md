# AES硬件Shuffling防护 - 深度实现笔记

## Section 1 - Sec 3.2 硬件随机化模块:

### 比较表
| 网络类型       | 开关数 | 排列数            |
|----------------|--------|-------------------|
| Benes网络      | 56     | 16!                |
| Omega网络      | 32     | 2^32              |

### Trivium PRNG 工作流程

Trivium PRNG的工作流程如下：
1. 初始化状态：
   - 设定初始值。
2. 生成伪随机位：
   - 根据反馈函数生成新位。

### ASCII图示：开关机制
```
+---+   +---+
| 1 |---| 2 |
+---+   +---+
```

## Section 2 - Sec 3.3 AES架构:

### 数据路径描述
从 Din 到 Dout 的数据路径经过 MEMi, SubBytes, MixColumns, MEMo。

### 表 1: 排列数组
| cpt | P[cpt] |
|-----|--------|
| 0   | 10     |
| 1   | 12     |
| 2   | 6      |
| 3   | 13     |
| 4   | 1      |
| 5   | 15     |
| 6   | 0      |
| 7   | 5      |
| 8   | 9      |
| 9   | 8      |
| 10  | 3      |
| 11  | 11     |
| 12  | 2      |
| 13  | 4      |
| 14  | 7      |
| 15  | 14     |

### 表 2: 逆排列
| idx | P_inv[idx] |
|-----|-------------|
| 0   | 6           |
| 1   | 4           |
| 2   | 12          |
| 3   | 10          |
| 4   | 13          |
| 5   | 7           |
| 6   | 2           |
| 7   | 14          |
| 8   | 9           |
| 9   | 8           |
| 10  | 0           |
| 11  | 11          |
| 12  | 1           |
| 13  | 3           |
| 14  | 15          |
| 15  | 5           |

### Python代码示例：构建逆排列
```python
def inverse_permutation(arr):
    return [arr.index(i) for i in range(len(arr))]

P = [10,12,6,13,1,15,0,5,9,8,3,11,2,4,7,14]
P_inv = inverse_permutation(P)
```

## Section 3 - Fig 4 调度时序:

### 336周期分解
- 32 初始化 + 32*9 轮 + 16 最终轮 + 16 输出

### MixColumns为什么分成两个阶段的解释
MixColumns的分阶段设计可以优化性能，减少延迟。

## Section 4 - Sec 4.1 安全性评估:

### SNR数据表
| SNR (dB)     |   |
|---------------|---|
| -94.61       |   |
| -184.42      |   |

### CPA攻击跟踪要求
- <100 traces (未保护) vs ~1M traces (保护)

### 10,000倍安全性提升的解释
通过引入硬件随机化，安全性提升显著。

## Section 5 - 硬件资源:

### Omega解决方案
- 194 slices
- 112.63 MHz
- 42.90 Mbit/s
